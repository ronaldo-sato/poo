Linguagem Java - CARACTERÍSTICAS

É uma linguagem orientada a objetos

(O paradigma da Orientação a Objetos (OO) surgiu com a linguagem de programação
Simula67, que foi a base do desenvolvimento da orientação a objetos; Simula67 
foi a base para a linguagem de programação Smalltalk nos anos 70, considerada 
a primeira linguagem autêntica de OO.)

(Alan Kay, um dos criadores do Smalltalk, formulou a analogia biológica: 
"como seria um sistema de software que funcionasse como um ser vivo?" - células 
interagindo com outras células através do envio de mensagens; cada célula se 
comportando como uma unidade autônoma; assim, a ideia foi como construir um 
sistema de software a partir de agentes autônomos que interagem entre si.)

Desenvolvida pela Sun Microsystems (hoje Oracle) em 1995

Modelada no C++

Projetada para ser pequena e simples, portável (para diferentes sistemas 
operacionais e arquiteturas; Portabilidade: "write once, run anywhere" 
- escreva uma vez, execute em qualquer lugar)

Linguagem compilada em bytecodes, que é executado por uma máquina virtual (Java
Virtual Machine; para rodar um programa em Java é preciso ter instalado a 
máquina virtual)

(Por isso o executável do programa de um programa em Java roda em diferentes 
sistemas, porque quem executa é a máquina virtual)

Possui extensa bilioteca com recursos de rede que facilita o trabalho com 
protocolos TCP/IP, como HTTP e FTP. Além disso, pode executar programa via rede
com segurança, através de restrições de execução

Suporta caracteres Unicode (facilita a internacionalização)

Distribuída com um vasto conjunto de bibliotecas (ou APIs)

Possui facilidades para criação de programas distribuídos e multitarefas 
(multiplas linhas sendo executadas num mesmo programa, ao invés de execução 
apenas sequencial)

Possui desalocação de memória automática por processo de coletor de lixo

Programas em Java são formados por uma coleção de classes armazenadas 
independentemente e que podem ser carregadas no momento de utilização (Carga 
Dinâmica de Código: em determinada parte do programa quando for usada 
determinada classe, a máquina virtual carrega essa classe dinamicamente a medida
que for sendo necessária, ao invés de carregar todo o programa em memória como
em muitas outras linguagens)


ETAPAS PARA COMPILAÇÃO

1) Criação do programa Java;

2) Compilação do programa Java em bytecodes: o compilador vai transformar o 
código.java em código.class (bytecodes), que representa as tarefas a serem 
executadas na fase de execução (bytecodes são portáteis e independem de 
plataforma);

3) Carrega o programa Java em memória: o Java Virtual Machine (JVM) armazena o 
programa em memória para executá-lo, efetuando o seu carregamento. O carregador
de classe, pega o .class (gerado na Etapa 2) que têm os bytecodes do programa 
e os transfere para a memória principal;

4) Verificar os bytecodes: enquanto as classes são carregadas, o verificador 
examina seus bytecodes para saber se são válidos;

5) Executar o programa Java: a JVM executa os bytecodes utilizando uma 
combinação de interpretação (Just in Time), conhecido como compilador Java 
HotSpot, o qual traduz os bytecodes para a linguagem de máquina, quando a JVM 
encontra novamente esses bytecodes.

Muitas vezes, os programas em Java são distribuídos na forma de um arquivo .jar,
como se fosse um .zip (pacote) com todos os .class para serem executados.  

Todo programa em Java tem um método chamado main e todo programa em Java por 
padrão, executa uma thread (iremos tratar sobre threads em aula posterior,
mas foi um conceito apresentado em Sistemas Operacionais quando se falou em 
ramificação de fluxo e processos).

Programação Orientada a Objetos (POO) é um paradigma de programação em que 
novos tipos de dados, além dos primitivos, são definidos conforme necessidade 
através de classes.

Orientação a Objetos (OO) é trazer coisas/fenômenos do mundo real para o mundo
da computação/programação e isso é possível pelo uso de classes.


CLASSES

Classes são moldes/receitas/gabaritos que permitem a criação de novos objetos
e descrevem as características comuns de vários objetos.

Uma classe representa um conjunto de objetos com características afins, isto é,
através da definição de uma classe, se estabelece, quais métodos/propriedades e
métodos/ações objetos dessa classe terá. 

    MÉTODOS: são as operações que podem ser executadas pelos objetos (então, 
    tudo que os objetos podem fazer em relação a acessar atributos da classe ou
    até mesmo outros métodos são feitos por métodos).

    ATRIBUTOS: são acessados, em geral, por meio de métodos definids pela classe
    e os modificadores de acesso definem as permissões de como isso pode ser 
    feito (como será visto adiante).

    CONSTRUTORES: são métodos com  mesmo nome da classe e não possui retorno.

Ou seja, uma classe define o comportamento dos objetos através de seus métodos,
e quais estados ele é capaz de manter através de seus atributos.

Classes podem especificar entidades físicas, conceituais e de software.

Definição de uma classe no contexto de orientação à objeto: ela vai 
especificar um pacote de instruções (tipos de dados, operações que podem ser
feitas, quem pode fazer essas operações, como essas operações são acessadas, 
qual a hierarquia de acesso para determinadas operações que fazem parte 
daquela classe,...)

A declaração da classe se dá primeiramente por meio de um modificador de 
acesso (visibilidade), que determina quem tem acesso a executar algumas 
instâncias dessa classe (instâncias são objetos).

Por padrão o nome da classe é o mesmo que o nome do programa.


OBJETOS

Trata-se de entidade que é capaz de salvar um estado (informação) e que oferece
um conjunto de operações (comportamentos) para verificar ou alterar esse estado. 

Em um modelo de sistema orientado a objetos, os componentes desse sistema são 
representados por objetos (objetos representam entidades reais).

Dessa forma, associa-se ao objeto:

    Estado: é definido pelas propriedades, ou seja, os atributos que ele possui 
    e pelos valores que tais propriedades assumem;

    Comportamento: é definido pela forma como o objeto reage, quando seu estado 
    muda e também pelo relacionamento com os outros objetos;

    Identidade: cada objeto é único.

Os objetos indicam o quão capaz é o sistema de guardar informações sobre o que
está sendo abstraído e em seguida interagir com ele.

Assim, objetos são abstrações que representam o mundo real, isto é, são as 
entidades mais próximas do mundo real que conseguimos visualizar.

Portanto, existe um gap semântico (distância) entre a realidade e sua 
representação, dependendo de quanto o objeto consegue representar. Assim, 
quanto mais curta a distância entre realidade e o modelo da realidade, mais 
real fica o programa.


ENCAPSULAMENTO (VISIBILIDADE)

O encapsulamento trata da visibilidade de informações dentro do objeto. Isso
permite modularidade e ocultação de informação (information hiding).

Dessa forma, o encapsulamento cria um pacote de software cujos métodos e 
variáveis são relacionados, ou seja, o encapsulamento envolve o relacionamento
de variáveis. Já a ocultação de informação indica que, a única parete do objeto 
que pode ser acessada pelo mundo externo, deve ser feita por meio de operações. 

Assim o objeto tem uma visão interna (como o objeto faz) e uma visão externa 
(o que o objeto faz).

Por exemplo, um telefone celular tem um funcionamento interno encapsulado 
(escondido) do usuário. Para utilizar o telefone, por exemplo realizar uma 
chamada ou enviar uma mensagem (visão externa), o usuário não precisa conhecer
os detalhes internos da eletrônica do celular (visão interna). Ou seja, o 
usuário não precisa saber como o funciona o celular por dentro, ele apenas 
precisa saber utilizar o celular. 

Exemplos:

    (Objeto) Lampada:
                        Atributos: ligada/desligada
                        Métodos: ligar/desligar

    (Objeto) Pessoa:
                        Atributos: nome, idade, altura
                        Métodos: falar, comer, dormir

    (Objeto) Carro:
                        Atributos: cor, motor, tração, câmbio
                        Métodos: ligar, desligar, acelerar, frear, virar

Em suma:

    Um objeto é uma instância de uma classe, uma instância é um objeto que 
pertence a uma classe. A classe é um molde, ela é sempre a mesma, ela descreve
características comuns a vários objetos, mas os objetos gerados por ela, são
diferentes tendo características variadas. 

    A classe é uma abstração e o objeto é a entidade concreta.

    Quando falamos em definição de uma classse, isso significa tornar formal um
tipo de dado e todas as operações que têm associação a este tipo. E quando 
falamos em definir um objeto, significa criar variáveis de um tipo definido por 
uma classe.


Nas classes, o encapsulamento se dá pela visibilidade (modificadores de acesso).


MODIFICADORES DE ACESSO (TIPOS DE ACESSO)

Atributos e métodos são membros de uma classe e para definir o tipo de acesso 
a esses membros, utilizamos os modificadores de acesso:

"public" (público; representado pelo sinal de "+" na notação UML): elementos 
declarados como público podem ser acessados por todas as entidades do sistema,
ou seja, podem ser acessados a partir de qualquer outra classe (uma classe pode
conversar com outra se seus métodos e/ou atributos estiverem públicos);

"protected" (protegido; representado pelo sinal "#" na notação UML): elementos 
protegidos podem ser acessados somente por classes da mesma hierarquia e mesmo 
pacote, ou seja, podem ser acessados somente pela própria classe e por suas 
decendentes (a classe filha poderá acessar métodos e atributos da classe pai 
se eles forem protegidos);

"private" (privado; representado pelo sinal de "-" na notação UML): elementos
declarados como privados só podem ser acessados pela própria classe (por 
métodos da própria classe), ou seja, uma classe externa não pode acessar ou o 
método que acessa elementos privados precisa estar definido dentro da própria
classe;

"default" (padrão; representado pelo sinal de "~" na notação UML): elementos 
padrão só podem ser acessados por classes do mesmo pacote.

Portanto, a escolha dos tipos de acesso definem o escopo dos métodos e 
atributos. Além disso, a definição dos tipos de acesso auxiliam na estabilidade
e na segurança do acesso a atributos ou ainda em ocultá-lo. 

É comum atributos serem "private" e desta forma, os métodos da própria classe é 
que são responsáveis por modificar e recuperar o estado desses atributos. E em 
geral, métodos setters e getters são públicos.


PILARES DA POO

ABSTRAÇÂO: ignora o que não é relevante e concentra-se apenas nos aspectos 
principais do problema. Classes são abstração de conceitos.

ENCAPSULAMENTO: capacidade de implementar dados e procedimentos que se 
correlacionam numa mesma entidade. A ideia é não depender do funcionamento 
interno, mas sim da sua interface.

HERANÇA: caracteriza-se pela hierarquização das classes de um sistema.

POLIMORFISMO: é um princípio em que um organismo pode surgir de formas distintas
(conceito oriundo da Biologia). Indivíduos da mesma espécie possuem 
características similares.

MENSAGENS: quando um objeto emissor transmite uma requisição para um objeto 
receptor para que este execute um comportamento (método) desejado. O objeto 
receptor precisa ter os métodos definidos para conseguir interagir (métodos 
getters e setters para recuperar ou modificar algu macesso, atributo que 
pertence aquela classe). Os métodos sempre respondem um retorno à uma chamada.


ENCAPSULAMENTO

Em POO, o encapsulamento significa dividir o programa em partes de maneira mais
isolada possível. 

Vantagens:

Isso torna o software/programa mais flexível, fácil de modificar e de 
implementar novas funcionalidades; permite controlar o acesso aos artributos e 
métodos de uma classe, protegendo os dados que serão manipulados em uma classe 
qualquer; e evita que os dados de uma aplicação sofram acessos indevidos.

A linguagem Java permite e utiliza muito o conceito de encapsulamento.

O encapculamento também permite a ocultação da informação (information hiding),
que é o mecanismo para restringir o acesso a alguns dos componentes do objeto. 

Então, a ocultação da informação está relacionada à restrição do acesso enquanto
o encapculamento está relacionado a separação do programa em partes, ao 
isolamento das partes. 

O encapsulamento é um conceito da POO em que os estados dos objetos (variáveis 
de classe) e seus comportamentos (métodos da classe) são agrupados em conjunto
segundo o seu grau de relação.

A ocultação da informação é parte do encapsulamento, mas é mais do que esconder 
os dados. A ocultação da informação é um critério base para modularizar 
sistemas, levando em conta a ocultação das decisões de desenho do projeto, que 
são suscetíveis a mudanças. 

Em suma, não é preciso saber como é feita a lógica de determinados métodos, pois
é somente preciso chamá-los e utilizar seus resultados. 


NÍVEIS DE ENCAPSULAMENTO

Nível de classe: quando determinamos o acesso de uma classe inteira (public ou 
package-private).

Nível de membro: quando determinamos o acesso de atributos ou métodos de uma 
classe que podem ser public, private, protected, package-private (depende de
atributo).

Para ter um método encapsulado utilizamos um modificador de acesso, além do 
tipo de retorno dele.

Na prática, o encapsulamento é feito por getters e setters:

    Setters: métodos que retornam o valor que foi solicitado, mas não prejudica
    a integridade do dado.

    Getters: métodos que recebem como argumento uma informação que pode ser de 
    qualquer tipo de dado suportado pela linguagem, o que evita acessos 
    indevidos.

Para exemplificar o funcionamento do encapsulamento, suponha um sistema de 
vendas em que temos diversos tipos de cadastros (funcionários, usuários, 
gerentes, clientes, produtos). Nesse caso, separar o que pode ser acessado e 
como pode ser acessado, diminui erros em acessar algum atributo de forma não
autorizada.

No encapsulamento, os atributos das classes são do tipo "private" e para esses 
modificadores é preciso criar métodos setters e getters para alterar ou acessar
o valor de uma propriedade.

Exemplificando o encapsulamento para uma classe Funcionario:

// Como é uma classe pública, pode ser acessada por outras classes
public class Funcionario(){

    // Atributos privados, não temos como acessar os valores senão por meio de
    // um método
    private double salario;
    private String nome;

    // Método getter para o nome
    public String getNome(){
        return nome;
    }

    // Método setter para o nome
    public void setNome(String nome){
        this.nome = nome;
    }

    // Método getter para o salario
    public double getSalario(){
        return salario;
    }

    // Método setter para o salario
    public setSalario(double salario){
        this.salario = salario;
    }

}


HERANÇA

Tomando como base o mundo real, os seres humanos herdam características de seus 
pais. Então, atributos como cor da pele, cor dos olhos e outros, assim como, até
mesmo comportamentos, podem ser herdados. 

Assim, da mesma forma seguindo essa ideia de herdar características, em POO as
classes podem herdar atributos (propriedades) e métodos (comportamentos), 
o que é chamado de herança.

Assim, em POO, a classe que terá suas características herdadas é chamada de 
classe mãe e também de superclasse ou de classe mais genérica, e as classes que 
herdam essas características são chamadas de classes filhas. 

Para exemplificar, suponha uma classe Pessoa mais genérica (em notação UML):

                            -----------------------
    ^                       | Pessoa              |   classe mãe            |
    |                       -----------------------   superclasse           |
    |           2 atributos | nome                |   classe mais genérica  |
    |                       | endereço            |                         |
    |                       -----------------------                         |
    |             2 métodos | comer()             |                         |
    |                       | dormir()            |                         |
    |                       -----------------------                         |
    |                                                                       |
    | generalização                                          especialização |
    |                                                                       |
    | -----------------------                     -----------------------   |
    | | Estudante           |   classes filhas    | Empregado           |   |
    | -----------------------     subclasses      -----------------------   |
    | | anoEscolar          |                     | categoria           |   |
    | -----------------------                     | função              |   |
    | | matricular()        |                     -----------------------   |
    | | estudar()           |                     | trabalhar()         |   |
    | -----------------------                     | reabastecer()       |   v
                                                  -----------------------

      classe mais específicas:                    classe mais específicas:
      3 atributos                                 4 atributos
      4 métodos                                   4 métodos

Assim, as classes filhas Estudante e Empregado além de possuir seus próprios
métodos e atributos, herdam os atributos e métodos da classe Pessoa.

Aqui nesse exemplos, os atributos da Pessoa é nome e endereço e os métodos é 
comer e dormir. Estudantes e empregados também são pessoas, então veja que um
estudante tem nome e endereço assim como o empregado. Ambos também podem comer
e dormir. Mas o estudante tem um ano escolar, ele pode ser matriculado em uma 
turma e pode estudar. Já o empregado tem uma categoria e uma função, ele 
trabalha e uma função é reabastecer. 

Portanto, quando criamos classes mais específicas, em geral, elas herdam 
características de classes mais genéricas.

Olhando do ponto de vista das subclasses, ou o contexto de cima para baixo, 
chamamos esse processo de especialização. E quando olhamos debaixo para cima,
chamamos de generalização.

Assim, classes mais genéricas podem especializar outras e classes filhas (ou 
classes mais especializadas) podem generalizar aspectos da classe mãe (ou 
classe mais genéricas).

Dessa forma, a herança pode ocorrer ou ser repetida em cascata. Por exemplo:

                Animal                      ---> superclasse

    Selvagem            Doméstico           ---> subclasses

                    Gato          Cachorro  ---> subclasses

Em Java, no conceito de herança usamos a nomenclatura de classes mãe, também 
chamadas de super classe ou classe base, e classes filha, também chamadas de 
subclasse ou classe derivada.

A classe mãe é a classe mais geral e de onde as outras classes herdam atributos
e métodos (membros) e a classe filha é mais especializada (herda os membros da
classe mãe).

Então, no exemplo acima, a classe Animal é a classe mãe (super classe), da qual
as classes filhas (subclasses) Selvagem e Doméstico herdam membros, e seguindo
a hierarquia, a classe Doméstico ainda tem duas classes filhas (subclasses), 
as classes Gato e Cachorro, que são mais especializadas.

Em Java, o uso de herança se dá pela palavra reservada "extends". Então,
seguindo a hierarquia acima, por exemplo:

public class Animal {
    // Corpo da classe mãe
}

public class Cachorro extends Animal {
    // Corpo da classe filha
}

Dessa forma, quando for instanciado um objeto da classe Cachorro, ele irá herdar
as características e propriedades da classe Animal, além de ter seus atributos e
métodos específicos.

VANTAGENS DA HERANÇA

    Permitir reuso de código (evita reescrever código)

    Possibilita especializar soluções gerais já existentes ()

OBS: Todo objeto da subclasse é um objeto da superclasse (classe mãe), mas o 
contrário não é válido. Então seguindo o exemplo acima, um o objeto cachorro 
também é um objeto animal.

Portanto, a classe filha herda todos os membros da classe mãe:

    Membros privados: são ocultos na classe filha;

    Membros públicos: acessíveis na classe filha;

    Membros protegidos: são acessíveis na subclasse (e outras do mesmo pacote).

CONCEITOS

Construtores não são membros da classe, mas as classes filhas podem chamar um
construtor da classe mãe.

Podemos declarar um campo na classe filha com o mesmo nome da classe mãe, mesmo
que os tipos sejam diferentes. 

Podemos sobreescrever um método da classe mãe, declarando um método com a mesma
assinatura (desde que o conjunto de parâmetros entre os métodos sejam 
diferentes), o que é chamado de polimorfismo (veremos abaixo).

Como já visto, podemos declarar novos métodos e campos na classe filha, o que 
é chamado de especialização.

Imagine que temos que modelar uma escola, que tem professores, alunos, 
funcionários,considerando que todos são pessoas. Então, Pessoa seria nossa 
classe mãe e as classes Professores, Funcionários e Alunos seriam as classes
filhas. 

public class Pessoa {
    public String nome;
    public String cpf;
    public Date dataNascimento;

    // Construtor
    public Pessoa(String nome, String cpf, Date dataNascimento){
        this.nome = nome;
        this.cpf = cpf;
        this.dataNascimento = dataNascimento;
    }
}

Então, estendendo essa a classe Pessoa para as demais classes:

// Subclasse Aluno
public class Aluno extends Pessoa {
    // Atributos especializados
    public String matricula;
    // Construtor
    public Aluno(String nome, String cpf, Date dataNascimento){
        super(nome, cpf, dataNascimento);
    }
}

// Subclasse Professor
public class Professor extends Pessoa {
    // Atributos especializados
    public double salario;
    public String disciplina;
    // Construtor
    public Professor(String nome, String cpf, Date dataNascimento){
        super(nome, cpf, dataNascimento);
    }
}

// Subclasse Funcionario
public class Funcionario extends Pessoa {
    // Atributos especializados
    public double salario;
    public Date dataAdmissao;
    public String cargo;
    // Construtor
    public Funcionario(String nome, String cpf, Date dataNascimento){
        super(nome, cpf, dataNascimento);
    }
}


POLIMORFISMO

Caracteriza-se por sobreescrever/reescrever um método da classe mãe, declarando
um método com a mesma assinatura. 

A vantagem disso, é que os objetos vão ter a capacidade de responder a uma 
mesma mensagem (chamada de métodos) de modos diferentes.

Por isso, a reescrita é também chamada de sobreposição.

Por exemplo no mundo real, carro, bibicleta, ônibus se movem. Sendo mover um 
método dessas classes, esse método poderá ser especializado em cada 
classe para mover o respectivo tipo, já que se movem de formas diferentes 
(então será o mesmo método mas com assinaturas diferentes, já que a ação
será a mesma mas o modo será distinto). 

Em relação à execução do programa quanto à sobreposição de métodos, a JVM 
(Java Virtual Machine) procura a implementação mais especializada seguindo a
hierarquia de baixo para cima, ou seja, da classe mais específica (filha) para
a classe mais genérica (mãe). Então, se o método estiver sobreescrito na classe
filha, estando implementado tanto na classe filha como na classe mãe, primeiro
o método é buscado primeiro na filha e depois na mãe. 

Se o método não for definido na classe filha, a JVM procura pela implementação
da classe mãe. Então, ao chamar um método na classe filha que não foi definido
nela, naturalmente estará sendo usado o método da classe mãe, mas primeiro a 
JVM procura por esse método (com mesmo nome embora com assinatura diferente) na 
classe filha, e não encontrando a JVM assume que o método usado é o da classe 
mãe, ainda que esse método esteja sendo usado dentro de uma classe mais 
especializada.

Quando um método é sobreescrito na classe filha, ele passa a ter o comportamento
padrão dessa classe, embora seja possível acessar o método da superclasse.

Portanto, a sobreescrita de métodos ocorre quando um método da classe mãe é 
redefinido na classe filha, assim, os métodos tem a mesma assinatura e o mesmo 
tipo de retorno.

Mas, se no caso for necessário utilizar o comportamento definido pela classe mãe
será preciso chamar a implementação da classe mãe utilizando a palavra "super", 
sobrepondo então o método da classe filha (overriding).

Isso ocorreu nas subclasses Aluno, Professor e Funcionário acima, onde nos 
respectivos construtores ao invés de reescrevermos as mesmas definições de 
parâmetros como feito na classe Pessoa, ao usar super o construtor de cada 
subclasse assume o comportamento da classe mãe.

Para exemplificar, suponha uma classe Carro:

public class Carro{
    private int velocidade;

    // Construtor
    public Carro(int velocidadeInicial){
        velocidade = velocidadeInicial;
    }

    // Método Acelera
    public void acelera(){
        velocidade++;
    }

    // Método Freia
    public void freia(){
        velocidade--;
    }
}

Vamos implementar outra classe CarroCorrida que vai herdar a classe Carro:

public class CarroCorrida extends Carro{

    // Construtor
    public CarroCorrida(int velocidadeInicial){
        super(velocidadeInicial)
    }

    // Reescrita do Método Acelera
    public void acelera(){
        velocidade += 5;
    }
}

Portanto, a instanciar um objeto CarroCorrida, esse objeto herda da classe mãe
Carro seus atributos e métodos:

CarroCorrida carro = new CarroCorrida();

Assim ao chamar o método acelera dentro da classe CarroCorrida, a velocidade 
será incrementada em 5, enquanto que se chamado dentro da classe Carro, será 
incrementada de 1.

carro.acelera();

Como o objeto carro é um carro de corrida e todo carro de corrida é um carro, 
o carro de corrida tem o método acelera assim como um carro tem o mesmo método,
mas como o objeto carro de corrida herda e reescreve o método acelera, ao chamar
o método acelera ele chama o método da classe filha.

A palavra "super" tem função parecida com a palavra "this" e esta é usada para
referenciar o próprio objeto, o que permite distinguir variáveis locais e 
campos do objeto que contém os mesmos nomes.

Anteriormente, utilizamos algumas vezes a palavra this e como exemplo veja a 
classe Pessoa:

public class Pessoa {
    public String nome;
    public String cpf;
    public Date dataNascimento;

    // Construtor
    public Pessoa(String nome, String cpf, Date dataNascimento){
        this.nome = nome;
        this.cpf = cpf;
        this.dataNascimento = dataNascimento;
    }
}

Observe que no construtor utilizamos "this" para referenciar o próprio objeto 
para distinguir o atributo nome, cpf e dataNascimento, dos respectivos 
parâmetros que o construtor recebe. Se a referência não tivesse sido feito, não
haveria como distinguir o nome atributo de nome parâmetro, assim o parâmetro 
em si precisaria ser nomeado de outra forma, por exemplo, nomePessoa.

Em herança, a palavra "super" é usada para acessar campos e métodos da 
superclasse (campos ocultos, métodos sobrescritos, construtores da superclasse).


CLASSES E MÉTODOS FINAL 

O modificador "final" indica que o método definido com ele não pode ser 
sobreescrito em uma subclasse. Este modificar pode ser aplicado em classes, 
métodos e atributos. 

Métodos privados são acessíveis apenas dentro da classe definida, não podendo
sobreescrever um método private em uma subclasse, quando usando o modificador 
final.

Para exemplificar, suponha a classe:

public final class ClasseFinal {
    protected final String nome;
    protected final int idade;
    protected final int[] vetor;

    // Primeiro construtor
    public ClasseFinal(){
        idade = 22;
        nome = "Univesp";
        vet = new int[100];
    }

    // Segundo construtor com mesma assinatura
    public ClasseFinal(int _idade, String _nome, int tamanho){
        idade = _idade;
        nome = _nome;
        vet = new int[tamanho];
    }

    public final void imprime(final int pos){
        System.out.println(vetor[pos]);
    }

    public final void inicializa(){
        for (int x=0; x < vetor.length; x++){
            vet[x] = x*5;
        }
    }

}

Dessa forma, ao chamar métodos final dentro da main ou fazer uso de herança 
em outra classe, esses métodos e atributos definidos com final não poderão 
ser alterados.


INTERFACES

O conceito de interface tem como principal objetivo criar um contrato em que a
classe implementadora deve obrigatoriamente obedecer. A ideia é que a classe 
interface, apenas indique quais métodos precisam ser implementados, portanto 
ela é uma classe abstrata que apenas contem a assinatura dos métodos, ela não
contém a implementação desses métodos (não possuem corpo).

Em Java, para usar interfaces isso é possível com o uso da palavra "interface".

No contexto de interface, quando programamos um software não importa como será
feita a implementação, pois o mais importante é saber a definição do contrato, 
para garantir que o software desenvolvido por um grupo se comunique com outro 
seguindo esse contrato.

Um exemplo do mundo real é o padrão USB (Universal Serial Bus), que é utilizado 
por inúmeros dispositivos computacionais. Dessa forma, as empresas que criam 
dispositivos precisam apenas conhecer o protocolo de uma conexão USB.

Assim, embora interface seja uma classe abstrata, ela é uma classe abstrata 
especial, pois possui apenas métodos abstratos e nenhuma implementação. Ou seja,
a classe abstrata não implementa nada, ela só define um contrato (o que precisa
ser seguidos: os métodos assinados na interface). 

Para a declaração de interface é usada a palavra reservada "interface", veja o 
exemplo de uma interface de uma classe:

public interface MinhaPrimeiraInterface{
    public void metodoUm();
    public int metodoDois();
    public String metodoTres(String parametroUm);
}

Observe que na classe MinhaPrimeiraInterface não há implementação, só há a 
declaração dos métodos no cabeçalho, dessa forma, obrigatoriamente devem ser 
implementados pela classe que implementar essa interface.

Ou seja, para quem for implementar essa classe (quem for criar uma classe com
base nessa interface), isso indica que ao implementar uma classe a partir dessa
interface, a classe implementadora vai precisar implementar esses três métodos
(metodoUm, metodoDois e metodoTres). Pois senão, a classe interface não serveria
de nada se não tivesse os métodos implementados (por essa razão a ideia de 
contrato, será preciso programar isso).

Então no exemplo anterior de interface, os métodos apresentam apenas uma 
assinatura, ou seja, não possuem corpo.

E isso é o contrato que deve ser seguido no caso da implementação, como exemplo
a classe abaixo implementa essa interface:

public class PrimeiraClasse implements MinhaPrimeiraInterface{
    // Implementacao metodo 1
    public void metodoUm(){
    }
    public void metodoDois(int valor){
        return valor;
    }
    public void metodoTres(String ){
        return null;
    }
    public static void main(String[] args){
        System.out.println("Implementacao Minha Primeira Interface")
    }
}

A sintaxe se assemelha àquela de Herança, mas ao invés de usar a palavra 
"extends", interface utiliza a palavra "implements".

Com a criação da classe PrimeiraClasse, podemos definir novas variáveis, novos
métodos (como setters e getters), e fazer tudo que for preciso, com a condição 
de que tudo que estiver na interface precisa estar obrigatoriamente na sua 
implementação.

Ou seja, se na interface tem um método que recebe argumentos específicos e 
retorna um tipo específico, sua implementação tem que obedecer esta mesma regra,
precisa receber os mesmos argumentos específicos e retornar o mesmo tipo lá 
descrito.

Interfaces podem ser definidas como public ou package-private (pode estar num 
pacote em que as classes podem interagir entre si).

Uma classe pode implementar várias interfaces:

public class MinhaClasse implements Interface0, Intrface2

Uma interface pode herdar várias outras classes:

public interface Interface0 extends Interface1, Interface2

(Note que o conceito de herança não se limita apenas a classes; podemos ter 
interfaces com características primárias que vão ser especializadas pelas
interfaces filhas.)

O uso de interfaces desde o início do desenvolvimento de um projeto pode poupar
muito tempo no futuro. (Sabendo o que o contrato define e se há herança entre 
esses contratos, já que interface é um contrato e uma interface pode herdar de 
outras interfaces pode haver contratos e subcontratos de modo que estes podem 
especializar suas próprias características, suas próprias peculariedades, mas 
podem herdar propriedades de um contrato maior, mais genericos.)

Criar uma interface para os métodos principais de uma classe e utilizar esta 
interface para acessá-los torna mais fácil o processo de manutenção de código
caso esta classe precise ser substituída posteriormente. (Se a gente precisar 
substituir uma classe que foi implementada na interface é muito mais fácil 
reescrever/refazer os métodos daquela interface, por exemplo, se quisermos 
definir uma nova classe ou uma nova estrutura de dados mais rápida para fazer 
inserção ou remoção de elemento, desde que o contrato seja respeitado a 
manutenção é facilitada, principalmente em equipes grandes de desenvolvimento.)

Portanto, as interfaces deixam o código mais reutilizável, já que uma única 
classe pode trabalhar com várias outras por meio de uma única interface. 


CLASSES ABSTRATAS

Usamos classes abstratas quando desejamos definir uma classe mais geral, 
representando objetos de modo mais genérico, porémm, sem instanciá-los 
(classes abstratas não produzem nenhum tipo de objeto).

Para declarar uma classe abstrata usamos a palavra "abstract", isso impede que 
objetos sejam instanciados a partir dela (a tentativa ocasiona erro).

Por exemplo, suponha um classe Veiculo com os métodos freia() e acelera(). 
Considere, que essa classe serve para ônibus, carro, caminhão, avião, jipe, 
onde cada subtipo de veículo será de uma subclasse (Carro, Onibus, Aviao,
Caminhao, Jipe). 

Dessa forma, a classe abstrata é como uma interface, porém sem implementação. 
Então, a gente define uma classe mais genérica que não será instanciada, a 
instanciação ocorre a partir da subclasse, que terá as características da 
classe abstrata.

Da mesma forma, métodos abstratos podem ser definidos em uma classe e para isso
a classe precisa ser abstrata. Isso, como na interface em que os métodos 
não são implementados, eles são implícitos, abstratos, estabelecendo assim, um
contrato, em que obriga outras classes implementarem, mas não obrigando o 
comportamento. 

Assim, a principal diferença é que uma classe abstrata pode ter métodos 
implementados. Outra distinção é que uma classe pode herdar de apenas uma 
classe (abstrata ou concreta), mas pode implementar múltiplas interfaces. 
As classes abstratas focam em herança e reutilização de código, enquanto 
as interfaces focam em definir um contrato ou um conjunto de comportamentos
que uma classe deve seguir. 

Portanto, classes abstratas podem conter métodos abstratos e não abstratos; 
podem conter campos como qualquer outra classe; não podem ser instanciadas; 
e pode ser herdada. 

Um exemplo de classe abstrata:

// Classe abstrata base
abstract class Animal {
    // Método concreto (com implementação) - as subclasses herdam este método
    void dormir() {
        System.out.println("Dormindo...");
    }

    // Método abstrato (sem implementação)
    abstract void fazerSom();
}

// Subclasse de Animal
class Cachorro extends Animal {
    // Implementação obrigatória do método abstrato
    @Override  // notação que indica sobreescevrer o respectivo método
    void fazerSom() {
        System.out.println("Au au, au.");
    }
}


Veja, que a classe Cachorro herda da classe abstrata Animal e para sobreescrever
o método fazerSom() da superclasse Animal, utilizamos "@Override".

Na classe abstrata Animal, métodos abstratos possuem comportamento diferente nas 
subclasses e por isso não são implementados.

Assim, as subclasses que herdam necessitam deste método, porém de forma mais 
específica e com suas particularidades (por exemplo, uma subclasse Gato, ao
invés de fazer "Au au, au", poderia fazer "Miau, ..., miau").

Comparando Classes Abstratas com Interfaces:

    Ambas não podem ser instanciadas;

    Classes abstratas podem apresentar campos que são "public static final"
    (constantes);

    Métodos concretos em classes abstratas podem ter definido seu modificador
    de acesso;

    Em interfaces, qualquer método é sempre public;

    Para classes que não têm relação entre si, ou seja, não há relação forte
    (herança), usa-se interfaces (aparecendo herança usa-se classe abstrata);

    Se é preciso oferecer atributos, é melhor usar classes abstratas, uma vez
    que com herança os atributos serão herdados.




